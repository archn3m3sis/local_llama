"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assert = exports.replaceTreeNode = exports.treeMap = exports.removeTreeNode = exports.appendTreeNode = exports.assignTreeNode = exports.isParentUri = exports.getParentNode = exports.getTreeNodeByUri = exports.getTreeNodePath = exports.getFileName = exports.calcLevel = exports.flatTreeData = void 0;
/**
 * 将树转换成列表
 * @param treeData
 * @returns
 */
function flatTreeData(treeData, sorter) {
    if (!treeData) {
        return [];
    }
    var fileTypeVal = {
        directory: 0,
        file: 1,
    };
    // 按字符串排序，目录在前面
    var list = [];
    var sorted = sorter ? sorter(treeData) : __spreadArray([], treeData, true);
    sorted.forEach(function (item) {
        list.push(item);
        if (item.expanded && item.children) {
            list = list.concat(flatTreeData(item.children, sorter));
        }
    });
    return list;
}
exports.flatTreeData = flatTreeData;
/**
 * 计算层级
 * @param uri
 * @param rootUri
 * @returns
 */
function calcLevel(uri, rootUri) {
    if (uri === rootUri)
        return 0;
    return uri.slice(rootUri.length).split("/").length;
}
exports.calcLevel = calcLevel;
/**
 * 根据uri获取文件名
 * @param uri
 * @returns
 */
function getFileName(uri) {
    return decodeURIComponent(uri.split("/").pop() || '');
}
exports.getFileName = getFileName;
/**
 * 根据uri获取节点路径
 * @param tree
 * @param uri
 * @returns
 */
function getTreeNodePath(tree, uri) {
    var _a;
    if (tree.uri === uri) {
        return [];
    }
    var path = [];
    var found = (_a = tree.children) === null || _a === void 0 ? void 0 : _a.find(function (item, index) {
        if (item.uri === uri) {
            path.push(index);
            return true;
        }
        var subPath = getTreeNodePath(item, uri);
        if (subPath) {
            path.push(index);
            path = path.concat(subPath);
            return true;
        }
        return false;
    });
    if (found)
        return path;
    return null;
}
exports.getTreeNodePath = getTreeNodePath;
/**
 * 根据子节点路径定位节点
 * @param tree
 * @param path
 * @returns
 */
function getTreeNodeByPath(tree, path) {
    var _a;
    if (!path.length) {
        return tree;
    }
    var first = path[0], rest = path.slice(1);
    return getTreeNodeByPath((_a = tree === null || tree === void 0 ? void 0 : tree.children) === null || _a === void 0 ? void 0 : _a[first], rest);
}
/**
 * 根据uri查询节点
 * @param tree
 * @param uri
 * @returns
 */
function getTreeNodeByUri(tree, uri) {
    if (!tree) {
        return undefined;
    }
    var path = getTreeNodePath(tree, uri);
    if (!path) {
        return null;
    }
    return getTreeNodeByPath(tree, path);
}
exports.getTreeNodeByUri = getTreeNodeByUri;
/**
 * 获取父节点
 * @param tree
 * @param uri
 * @returns
 */
function getParentNode(tree, uri) {
    if (!tree) {
        return null;
    }
    var path = getTreeNodePath(tree, uri);
    if (!path) {
        return null;
    }
    path.pop();
    return getTreeNodeByPath(tree, path);
}
exports.getParentNode = getParentNode;
function isParentUri(curUri, parentUri) {
    return curUri.startsWith(parentUri) && curUri[parentUri.length] === "/";
}
exports.isParentUri = isParentUri;
/**
 * 更新节点属性，并返回新的树
 * @param tree
 * @param uri
 * @param newProps
 * @returns
 */
function assignTreeNode(tree, uri, newProps) {
    if (!tree) {
        return undefined;
    }
    var path = getTreeNodePath(tree, uri);
    if (!path) {
        return tree;
    }
    var node = getTreeNodeByPath(tree, path);
    var newNode = __assign(__assign({}, node), newProps);
    var index = path.pop();
    while (index >= 0) {
        var parent_1 = getTreeNodeByPath(tree, path);
        var children = __spreadArray([], parent_1.children, true);
        children.splice(index, 1, newNode);
        newNode = __assign(__assign({}, parent_1), { children: children });
        index = path.pop();
    }
    return newNode;
}
exports.assignTreeNode = assignTreeNode;
/**
 * 为节点增加子节点
 * @param tree
 * @param parentUri
 * @param node
 * @returns
 */
function appendTreeNode(tree, parentUri, node) {
    var _a;
    if (!tree) {
        return undefined;
    }
    var path = getTreeNodePath(tree, parentUri);
    if (!path) {
        return tree;
    }
    var locatedNode = getTreeNodeByPath(tree, path);
    if ((_a = locatedNode === null || locatedNode === void 0 ? void 0 : locatedNode.children) === null || _a === void 0 ? void 0 : _a.find(function (n) { return n.uri === node.uri; })) {
        console.warn("重复uri");
        return tree;
    }
    var children = __spreadArray(__spreadArray([], (locatedNode.children || []), true), [node], false);
    return assignTreeNode(tree, parentUri, { children: children });
}
exports.appendTreeNode = appendTreeNode;
/**
 * 从树中删除某节点
 * @param tree
 * @param uri
 * @returns
 */
function removeTreeNode(tree, uri) {
    if (!tree) {
        return undefined;
    }
    var path = getTreeNodePath(tree, uri);
    if (!path) {
        return tree;
    }
    // 删除根节点
    if (!path.length) {
        return undefined;
    }
    var index = path.pop();
    var parentPath = path;
    var parent = getTreeNodeByPath(tree, parentPath);
    var children = __spreadArray([], (parent.children || []), true);
    children.splice(index, 1);
    return assignTreeNode(tree, parent.uri, { children: children });
}
exports.removeTreeNode = removeTreeNode;
/**
 * 遍历树，生成新的树，叶子节点优先遍历
 * @param tree
 * @param fn
 * @returns
 */
function treeMap(tree, fn) {
    if (tree.children) {
        var childrenChanged_1 = false;
        var newChildren = tree.children.map(function (node) {
            var newNode = treeMap(node, fn);
            if (newNode !== node) {
                childrenChanged_1 = true;
            }
            return newNode;
        });
        if (childrenChanged_1) {
            return fn(__assign(__assign({}, tree), { children: newChildren }));
        }
    }
    return fn(tree);
}
exports.treeMap = treeMap;
var replaceTreeNode = function (tree, uri, newTreeNode) {
    if (!tree) {
        return undefined;
    }
    return treeMap(tree, function (treeNode) {
        if (treeNode.uri === uri) {
            return newTreeNode;
        }
        return treeNode;
    });
};
exports.replaceTreeNode = replaceTreeNode;
var assert = function (condition, msg) {
    if (!condition) {
        throw new Error(msg);
    }
};
exports.assert = assert;
