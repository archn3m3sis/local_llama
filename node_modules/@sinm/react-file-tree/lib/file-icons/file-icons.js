"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClassWithDarkColor = exports.getClassWithColor = exports.getClass = exports.db = void 0;
var icondb = __importStar(require("./db/icondb"));
var cache = {
    directoryName: {},
    directoryPath: {},
    fileName: {},
    filePath: {},
    interpreter: {},
    scope: {},
    language: {},
    signature: {},
};
/**
 * Icon
 *
 * @see {@link https://github.com/websemantics/file-icons-js/blob/master/index.js#L1107}
 */
/**
 * Create Icon instance
 */
var Icon = /** @class */ (function () {
    function Icon(index, data) {
        /** priority that determined icon's order of appearance */
        this.priority = 1;
        /** Match against system path instead of basename */
        this.matchPath = false;
        /** to match executable names in hashbangs */
        this.interpreter = null;
        /** to match grammar scope-names */
        this.scope = null;
        /** to match alias patterns */
        this.lang = null;
        /** to match file signatures */
        this.signature = null;
        this.index = index;
        this.icon = data[0];
        this.color = data[1];
        this.match = data[2];
        this.priority = data[3] || 1;
        this.matchPath = data[4] || false;
        this.interpreter = data[5] || null;
        this.scope = data[6] || null;
        this.lang = data[7] || null;
        this.signature = data[8] || null;
    }
    /**
     * Return the CSS classes for displaying the icon.
     *
     * @param {Number|null} colorMode
     * @param {Boolean} asArray
     * @return {String}
     */
    Icon.prototype.getClass = function (colorMode, asArray) {
        colorMode = colorMode !== undefined ? colorMode : null;
        asArray = asArray !== undefined ? asArray : false;
        // No color needed or available
        if (colorMode === null || this.color[0] === null)
            return asArray ? [this.icon] : this.icon;
        return asArray
            ? [this.icon, this.color[colorMode]]
            : this.icon + ' ' + this.color[colorMode];
    };
    return Icon;
}());
/**
 * Create IconTables instance
 */
var IconTables = /** @class */ (function () {
    function IconTables(data) {
        this.directoryIcons = this.read(data[0]);
        this.fileIcons = this.read(data[1]);
        this.binaryIcon = this.matchScope('source.asm');
        this.executableIcon = this.matchInterpreter('bash');
    }
    /**
     * Populate icon-lists from a icons data table.
     */
    IconTables.prototype.read = function (table) {
        var rawIcons = table[0], rawIndexes = table[1];
        var icons = rawIcons.map(function (icon, index) { return new Icon(index, icon); });
        // Dereference Icon instances from their stored offset
        var indexes = rawIndexes.map(function (index) {
            return index.map(function (offset) { return icons[offset]; });
        });
        return {
            byName: icons,
            byInterpreter: indexes[0],
            byLanguage: indexes[1],
            byPath: indexes[2],
            byScope: indexes[3],
            bySignature: indexes[4],
        };
    };
    /**
     * Match an icon using a resource's basename.
     *
     * @param name - Name of filesystem entity
     * @param directory - Match folders instead of files
     */
    IconTables.prototype.matchName = function (name, directory) {
        if (directory === void 0) { directory = false; }
        directory = directory !== undefined ? directory : false;
        var cachedIcons = directory
            ? cache.directoryName
            : cache.fileName;
        var icons = directory
            ? this.directoryIcons.byName
            : this.fileIcons.byName;
        if (cachedIcons[name]) {
            return cachedIcons[name];
        }
        for (var i in icons) {
            var icon = icons[i];
            if (icon.match.test(name))
                return (cachedIcons[name] = icon);
        }
        return null;
    };
    /**
     * Match an icon using a resource's system path.
     *
     * @param path - Full pathname to check
     * @param directory - Match folders instead of files
     */
    IconTables.prototype.matchPath = function (path, directory) {
        if (directory === void 0) { directory = false; }
        directory = directory !== undefined ? directory : false;
        var cachedIcons = directory ? cache.directoryName : cache.fileName;
        var icons = directory
            ? this.directoryIcons.byPath
            : this.fileIcons.byPath;
        if (cachedIcons[path]) {
            return cachedIcons[path];
        }
        for (var i in icons) {
            var icon = icons[i];
            if (icon.match.test(path))
                return (cachedIcons[path] = icon);
        }
        return null;
    };
    /**
     * Match an icon using the human-readable form of its related language.
     *
     * Typically used for matching modelines and Linguist-language attributes.
     *
     * @example IconTables.matchLanguage("JavaScript")
     * @param name - Name/alias of language
     */
    IconTables.prototype.matchLanguage = function (name) {
        var _a;
        if (cache.language[name])
            return cache.language[name];
        for (var i in this.fileIcons.byLanguage) {
            var icon = this.fileIcons.byLanguage[i];
            if ((_a = icon.lang) === null || _a === void 0 ? void 0 : _a.test(name)) {
                return (cache.language[name] = icon);
            }
        }
        return null;
    };
    /**
     * Match an icon using the grammar-scope assigned to it.
     *
     * @example IconTables.matchScope("source.js")
     * @param {String} name
     * @return {Icon}
     */
    IconTables.prototype.matchScope = function (name) {
        var _a;
        if (cache.scope[name])
            return cache.scope[name];
        for (var i in this.fileIcons.byScope) {
            var icon = this.fileIcons.byScope[i];
            if ((_a = icon.scope) === null || _a === void 0 ? void 0 : _a.test(name))
                return (cache.scope[name] = icon);
        }
        return null;
    };
    /**
     * Match an icon using the name of an interpreter which executes its language.
     *
     * Used for matching interpreter directives (a.k.a., "hashbangs").
     *
     * @example IconTables.matchInterpreter("bash")
     */
    IconTables.prototype.matchInterpreter = function (name) {
        var _a;
        if (cache.interpreter[name])
            return cache.interpreter[name];
        for (var i in this.fileIcons.byInterpreter) {
            var icon = this.fileIcons.byInterpreter[i];
            if ((_a = icon.interpreter) === null || _a === void 0 ? void 0 : _a.test(name)) {
                return (cache.interpreter[name] = icon);
            }
        }
        return null;
    };
    return IconTables;
}());
/* ---------------------------------------------------------------------------
 * FileIcons
 * ------------------------------------------------------------------------- */
exports.db = new IconTables(icondb);
/**
 * Get icon class name of the provided filename. If not found, default to text icon.
 *
 * @param name - file name
 * @return the icon's class
 * @public
 */
var getClass = function (name, match) {
    if (match === void 0) { match = exports.db.matchName(name); }
    return match ? match.getClass() : null;
};
exports.getClass = getClass;
/**
 * Get icon class name of the provided filename with color. If not found, default to text icon.
 *
 * @param name - file name
 * @return the icon's class
 * @public
 */
var getClassWithColor = function (name, match) {
    if (match === void 0) { match = exports.db.matchName(name); }
    return match ? match.getClass(0) : null;
};
exports.getClassWithColor = getClassWithColor;
/**
 * Get icon class name of the provided filename with dark color. If not found, default to text icon.
 *
 * @param name - file name
 * @return the icon's class
 * @public
 */
var getClassWithDarkColor = function (name, match) {
    if (match === void 0) { match = exports.db.matchName(name); }
    return (match ? match.getClass(1) : null);
};
exports.getClassWithDarkColor = getClassWithDarkColor;
